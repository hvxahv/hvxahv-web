import type {NextPage} from 'next'
import Head from 'next/head'
import styles from '../../styles/Home.module.css'
import {useEffect, useState} from "react";
import {useRouter} from "next/router";
import {createClient} from "../../components/matrix/client";

const Messages: NextPage = () => {
  const route = useRouter()
  const [token, setToken] = useState("")
  const [userID, setUserID] = useState("")
  const [homeServer, setHomeServer] = useState("")
  useEffect(() => {
    const matrixToken = localStorage.getItem("hvxahv_matrix_token")
    const matrixUserId = localStorage.getItem("hvxahv_matrix_userid")
    const matrixHomeServer = localStorage.getItem("hvxahv_matrix_server")

    if (matrixToken == "undefined" || matrixUserId == "undefined" ||
      matrixHomeServer == "undefined" || matrixToken == null ||
      matrixUserId == null || matrixHomeServer == null) {
      const token = localStorage.getItem("hvxahv_login_token")
      const myHeaders = new Headers();
      myHeaders.append("Authorization", `Bearer ${token}`);

      const requestOptions = {
        method: 'GET',
        headers: myHeaders,
        redirect: 'follow'
      };

      // @ts-ignore
      fetch("http://localhost:8088/api/v1/message/access", requestOptions)
        .then(res => res.json())
        .then(res => {
          console.log(res)
          if (res.code == "401") {
            route.push("/messages/register").then(() => {
            })
          }
          console.log(res.matrix.Token)
          localStorage.setItem("hvxahv_matrix_token", res.matrix.Token)
          localStorage.setItem("hvxahv_matrix_userid", res.matrix.UserId)
          localStorage.setItem("hvxahv_matrix_server", res.matrix.HomeServer)
          setToken(res.matrix.Token)
          setUserID(res.matrix.UserId)
          setHomeServer(res.matrix.HomeServer)
        })
        .catch(error => console.log('error', error));
    } else {
      setToken(matrixToken)
      setUserID(matrixUserId)
      setHomeServer(matrixHomeServer)
    }
  }, [homeServer, route, token, userID])

  const [roomTimeline, setRoomTimeline] = useState<any>([])
  const [joinedRooms, setJoinedRooms] = useState<any>([])
  useEffect(() => {
    if (token != "") {
      (async () => {
        const client = await createClient(token, userID)

        client.once('sync', async function (state, prevState, res) {
          if (state === 'PREPARED') {
            const rooms = await client.getJoinedRooms();
            // console.log(rooms)
            rooms.joined_rooms.map((i, idx) => {
              const room = client.getRoom(i)
              setJoinedRooms((r: any) => [...r, room]);
            })
          }
        })

        client.on("RoomMember.membership", function(event, member) {
          if (member.membership === "invite" && member.userId === userID) {
            client.joinRoom(member.roomId).then(function() {
              console.log("Auto-joined %s", member.roomId);
            });
          }
        })

        client.on("Room.timeline", function(event, room, toStartOfTimeline) {
          if (toStartOfTimeline) {
            return; // don't print paginated results
          }
          if (event.getType() !== "m.room.message") {
            return; // only print messages
          }
          // console.log(room)
          console.log(
            // the room name will update with m.room.name events automatically
            "(%s) %s :: %s", room.name, event.getSender(), event.getContent().body
          )
          setRoomTimeline((r: any) => [...r, `Contact:${room.name}, Sender:${event.getSender()}, Message:${event.getContent().body}`])


        })



      })()
    }
  }, [homeServer, token, userID])

  const [message, setMessage] = useState("")

  const send = async (roomId: string) => {
    const client = await createClient(token, userID)
    const content = {
      "body": message,
      "msgtype": "m.text"
    };
    await client.sendEvent(roomId, "m.room.message", content, "", (err, res) => {
      console.log(err);
    });
  }
  // console.log(joinedRooms)
  // console.log(roomTimeline)
  return (
    <div className={styles.container}>
      <Head>
        <title>Messages</title>
        <meta name="description" content="Generated by create next app"/>
        <link rel="icon" href="/favicon.ico"/>
      </Head>

      <main className={styles.main}>

        <h1>Messages</h1>
        {joinedRooms && joinedRooms.map((i: any, idx: any) => {
          return (
            <div key={idx}>
              <div>{i.name != "Empty room" ? <div>{i.name}</div> : null} </div>
              <input type="text" onChange={e => setMessage(e.target.value)}/>
              <button onClick={() => send(i.roomId)}>Send</button>
            </div>
          )
        })}
        <hr/>
        <h1>Chat</h1>
        {roomTimeline && roomTimeline.map((i: any, idx: any) => {
          return (
            <div key={idx}>
              <div>{i}</div>
              <hr/>
            </div>
          )
        })}
      </main>

      <footer className={styles.footer}>

      </footer>
    </div>
  )
}

export default Messages
